#!/bin/bash

# Independent JSON-based metadata system
# Provides atomic operations for variables, arrays, and objects
# Requires: jq (JSON processor)

# Set default print_debug if not provided by calling script
if [[ -z "$print_debug" ]]; then
    print_debug="echo"
fi

# Default metadata file path (can be overridden by setting METADATA_JSON)
METADATA_JSON="${METADATA_JSON:-./metadata.json}"

# ========= CORE OPERATIONS =========

# Initialize JSON file
init_metadata_json() {
    local json_dir
    json_dir="$(dirname "$METADATA_JSON")"

    # Create directory if needed
    if [[ ! -d "$json_dir" ]]; then
        mkdir -p "$json_dir" || {
            $print_debug "Failed to create metadata directory: $json_dir" -t "error"
            return 1
        }
    fi

    # Create empty JSON object if file doesn't exist
    if [[ ! -f "$METADATA_JSON" ]]; then
        echo '{}' > "$METADATA_JSON" || {
            $print_debug "Failed to initialize metadata JSON file" -t "error"
            return 1
        }
    fi
}

# ======== INTERNAL HELPERS (locking, temp files) ========
# Create a temp file in the same directory as the metadata file (for atomic mv)
_mktemp_metadata() {
    local dir
    dir="$(dirname "$METADATA_JSON")"
    mktemp "$dir/.metadata.tmp.XXXXXX"
}

# Acquire an advisory lock if flock is available
# Acquire an advisory lock if flock is available
_acquire_metadata_lock() {
    # Skip locking in go-task environments (they dont support complex FD operations)
    if [[ "$0" == *"go-task"* ]] || [[ -n "$TASK_VERSION" ]] || [[ -n "$TASKFILE" ]] || [[ "$_" == *"go-task"* ]]; then
        return 0  # No locking, just continue
    fi
    
    # Use proper FD-based locking for regular bash environments
    if command -v flock >/dev/null 2>&1; then
        local lock_file="${METADATA_JSON}.lock"
        exec 200>"$lock_file" || return 1
        flock -w 5 200 || return 1
    fi
    return 0
}

# Release the advisory lock
_release_metadata_lock() {
    # Skip in go-task environments
    if [[ "$0" == *"go-task"* ]] || [[ -n "$TASK_VERSION" ]] || [[ -n "$TASKFILE" ]] || [[ "$_" == *"go-task"* ]]; then
        return 0
    fi
    
    # Proper cleanup for regular bash
    if command -v flock >/dev/null 2>&1; then
        flock -u 200 2>/dev/null || true
        exec 200>&-
    fi
}

# Set a variable (nested dot-path semantics; removes legacy flat dotted key)
# Usage: set_json_var "wallpaper.current.path" "/path/to/wallpaper.jpg"
set_json_var() {
    local key="$1"
    local value="$2"

    if [[ -z "$key" ]]; then
        $print_debug "Error: Variable key is required" -t "error"
        return 1
    fi

    init_metadata_json || return 1
    _acquire_metadata_lock || $print_debug "Warning: could not acquire lock, proceeding without it" -t "debug" --redirect-to-stderr

    local temp_file
    temp_file=$(_mktemp_metadata) || {
        _release_metadata_lock
        $print_debug "Failed to create temporary file" -t "error"
        return 1
    }

    if jq --arg key "$key" --arg val "$value" '
        setpath(($key|split(".")); $val)
        | (if ($key | contains(".")) then del(.[$key]) else . end)
    ' "$METADATA_JSON" > "$temp_file" && mv "$temp_file" "$METADATA_JSON"; then
        $print_debug "Set $key = $value" -t "debug" --redirect-to-stderr
        _release_metadata_lock
        return 0
    else
        rm -f "$temp_file"
        _release_metadata_lock
        $print_debug "Failed to set variable: $key" -t "error"
        return 1
    fi
}


# Set a variable with a JSON value (typed)
# Usage: set_json_var_json "some.path" '{"n":123, "flag":true}'
set_json_var_json() {
    local key="$1"
    local json="$2"

    if [[ -z "$key" || -z "$json" ]]; then
        $print_debug "Error: Both key and JSON value are required" -t "error"
        return 1
    fi

    init_metadata_json || return 1
    _acquire_metadata_lock || $print_debug "Warning: could not acquire lock, proceeding without it" -t "debug" --redirect-to-stderr

    local temp_file
    temp_file=$(_mktemp_metadata) || {
        _release_metadata_lock
        $print_debug "Failed to create temporary file" -t "error"
        return 1
    }

    if jq --arg key "$key" --argjson val "$json" '
        setpath(($key|split(".")); $val)
        | (if ($key | contains(".")) then del(.[$key]) else . end)
    ' "$METADATA_JSON" > "$temp_file" && mv "$temp_file" "$METADATA_JSON"; then
        $print_debug "Set (typed) $key" -t "debug" --redirect-to-stderr
        _release_metadata_lock
        return 0
    else
        rm -f "$temp_file"
        _release_metadata_lock
        $print_debug "Failed to set (typed) variable: $key" -t "error"
        return 1
    fi
}

# Get a variable value (nested dot-path with flat-key fallback)
# Usage: get_json_var "wallpaper.current.path"
get_json_var() {
    local key="$1"

    if [[ -z "$key" ]]; then
        $print_debug "Error: Variable key is required" -t "error"
        return 1
    fi

    if [[ ! -f "$METADATA_JSON" ]]; then
        echo ""
        return 0
    fi

    jq -r --arg key "$key" '
        ((getpath(($key|split("."))) // .[$key]) // empty)
        | if . == null then "" else (if type=="string" then . else tostring end) end
    ' "$METADATA_JSON" 2>/dev/null
    return 0
}

# Check if a variable exists and is not null/empty (nested with flat-key fallback)
# Usage: has_json_var "wallpaper.current.path"
has_json_var() {
    local key="$1"

    if [[ -z "$key" ]]; then
        return 1
    fi

    if [[ ! -f "$METADATA_JSON" ]]; then
        return 1
    fi

    local value
    value=$(jq -r --arg key "$key" '
        ((getpath(($key|split("."))) // .[$key]) // empty)
        | if . == null then "" else (if type=="string" then . else tostring end) end
    ' "$METADATA_JSON" 2>/dev/null)

    [[ -n "$value" ]]
}

# Delete a variable at nested path and legacy flat key
# Usage: unset_json_var "wallpaper.current.path"
unset_json_var() {
    local key="$1"

    if [[ -z "$key" ]]; then
        return 0
    fi

    if [[ ! -f "$METADATA_JSON" ]]; then
        return 0
    fi

    _acquire_metadata_lock || $print_debug "Warning: could not acquire lock, proceeding without it" -t "debug" --redirect-to-stderr

    local temp_file
    temp_file=$(_mktemp_metadata) || {
        _release_metadata_lock
        $print_debug "Failed to create temporary file" -t "error"
        return 1
    }

    if jq --arg key "$key" '
        delpaths([($key|split("."))])
        | del(.[$key])
    ' "$METADATA_JSON" > "$temp_file" && mv "$temp_file" "$METADATA_JSON"; then
        $print_debug "Unset variable: $key" -t "debug" --redirect-to-stderr
        _release_metadata_lock
        return 0
    else
        rm -f "$temp_file"
        _release_metadata_lock
        $print_debug "Failed to unset variable: $key" -t "error"
        return 1
    fi
}

# List all variables with a prefix (nested semantics)
# Usage: list_json_vars "prefix"
list_json_vars() {
    local prefix="$1"

    if [[ ! -f "$METADATA_JSON" ]]; then
        return 0
    fi

    if [[ -n "$prefix" ]]; then
        jq -r --arg prefix "$prefix" '
            (getpath(($prefix|split("."))) // {})
            | paths(scalars) as $p
            | ($p | join("."))
            | ($prefix + "." + .)
        ' "$METADATA_JSON" 2>/dev/null
    else
        jq -r 'paths(scalars) as $p | $p | join(".")' "$METADATA_JSON" 2>/dev/null
    fi
}

# Set multiple variables atomically (nested paths; single jq pass)
# Usage: set_json_vars "key1=value1" "key2=value2" "key3=value3"
set_json_vars() {
    init_metadata_json || return 1

    _acquire_metadata_lock || $print_debug "Warning: could not acquire lock, proceeding without it" -t "debug" --redirect-to-stderr

    local temp_file
    temp_file=$(_mktemp_metadata) || {
        _release_metadata_lock
        $print_debug "Failed to create temporary file" -t "error"
        return 1
    }

    # Build a JSON array of assignment objects [{k:"...", v:"..."}, ...]
    local assignments_json
    assignments_json=$(printf '%s
' "$@" | awk -F'=' '{k=$1; v=substr($0, index($0, "=")+1); gsub(/"/,"\\\"",v); printf "{\"k\":\"%s\",\"v\":\"%s\"}\n", k, v }' | paste -sd',' -) || assignments_json=""

    if jq --argjson assigns "[$assignments_json]" '
        reduce $assigns[] as $a (.; setpath(($a.k|split(".")); $a.v) | (if ($a.k|contains(".")) then del(.[$a.k]) else . end))
    ' "$METADATA_JSON" > "$temp_file" && mv "$temp_file" "$METADATA_JSON"; then
        _release_metadata_lock
        $print_debug "Successfully set multiple variables atomically" -t "debug" --redirect-to-stderr
        return 0
    else
        rm -f "$temp_file"
        _release_metadata_lock
        $print_debug "Failed to apply changes atomically" -t "error"
        return 1
    fi
}

# Get all variables as key=value pairs
# Usage: dump_json_vars
dump_json_vars() {
    if [[ ! -f "$METADATA_JSON" ]]; then
        return 0
    fi

    jq -r 'paths(scalars) as $p | ($p | join(".")) + "=" + (getpath($p) | tostring)' "$METADATA_JSON" 2>/dev/null
}

# ========= ARRAY OPERATIONS =========

# Set entire array
# Usage: set_json_array "cache.wallpapers" "/path/1" "/path/2" "/path/3"
set_json_array() {
    local key="$1"
    shift
    local values=("$@")

    if [[ -z "$key" ]]; then
        $print_debug "Error: Variable key is required" -t "error"
        return 1
    fi

    init_metadata_json || return 1
    _acquire_metadata_lock || $print_debug "Warning: could not acquire lock, proceeding without it" -t "debug" --redirect-to-stderr

    local temp_file
    temp_file=$(_mktemp_metadata) || {
        _release_metadata_lock
        $print_debug "Failed to create temporary file" -t "error"
        return 1
    }

    # Build JSON array from values
    local json_array
    if [[ ${#values[@]} -eq 0 ]]; then
        json_array="[]"
    else
        json_array=$(printf '%s\n' "${values[@]}" | jq -R . | jq -s .)
    fi

    if jq --arg key "$key" --argjson arr "$json_array" '
        ($key|split(".")) as $p
        | setpath($p; $arr)
        | (if ($key | contains(".")) then del(.[$key]) else . end)
    ' "$METADATA_JSON" > "$temp_file" && mv "$temp_file" "$METADATA_JSON"; then
        $print_debug "Set array $key with ${#values[@]} elements" -t "debug" --redirect-to-stderr
        _release_metadata_lock
        return 0
    else
        rm -f "$temp_file"
        _release_metadata_lock
        $print_debug "Failed to set array: $key" -t "error"
        return 1
    fi
}

# Get array as individual lines (nested with flat-key fallback)
# Usage: get_json_array "cache.wallpapers"
get_json_array() {
    local key="$1"

    if [[ -z "$key" ]]; then
        $print_debug "Error: Variable key is required" -t "error"
        return 1
    fi

    if [[ ! -f "$METADATA_JSON" ]]; then
        return 0
    fi

    jq -r --arg key "$key" '
        ((getpath(($key|split("."))) // .[$key]) // [])[]? // empty
    ' "$METADATA_JSON" 2>/dev/null
}

# Get array length (nested with flat-key fallback)
# Usage: get_json_array_length "cache.wallpapers"
get_json_array_length() {
    local key="$1"

    if [[ ! -f "$METADATA_JSON" ]]; then
        echo "0"
        return 0
    fi

    jq -r --arg key "$key" '
        ((getpath(($key|split("."))) // .[$key]) // []) | length
    ' "$METADATA_JSON" 2>/dev/null
}

# Get array element at specific index (nested with flat-key fallback)
# Usage: get_json_array_element "cache.wallpapers" 0
get_json_array_element() {
    local key="$1"
    local index="$2"

    if [[ -z "$key" || -z "$index" ]]; then
        $print_debug "Error: Both key and index are required" -t "error"
        return 1
    fi

    if [[ ! -f "$METADATA_JSON" ]]; then
        echo ""
        return 0
    fi

    jq -r --arg key "$key" --argjson i "$index" '
        ((getpath(($key|split("."))) // .[$key]) // [])[$i] // empty
    ' "$METADATA_JSON" 2>/dev/null
}

# Set array element at specific index (nested path)
# Usage: set_json_array_element "cache.wallpapers" 0 "/new/path"
set_json_array_element() {
    local key="$1"
    local index="$2"
    local value="$3"

    if [[ -z "$key" || -z "$index" || -z "$value" ]]; then
        $print_debug "Error: Key, index, and value are required" -t "error"
        return 1
    fi

    init_metadata_json || return 1
    _acquire_metadata_lock || $print_debug "Warning: could not acquire lock, proceeding without it" -t "debug" --redirect-to-stderr

    local temp_file
    temp_file=$(_mktemp_metadata) || {
        _release_metadata_lock
        $print_debug "Failed to create temporary file" -t "error"
        return 1
    }

    if jq --arg key "$key" --argjson i "$index" --arg val "$value" '
        setpath(($key|split(".") + [$i]); $val)
    ' "$METADATA_JSON" > "$temp_file" && mv "$temp_file" "$METADATA_JSON"; then
        $print_debug "Set array element $key[$index] = $value" -t "debug" --redirect-to-stderr
        _release_metadata_lock
        return 0
    else
        rm -f "$temp_file"
        _release_metadata_lock
        $print_debug "Failed to set array element: $key[$index]" -t "error"
        return 1
    fi
}

# Push element to end of array (nested path)
# Usage: push_json_array "cache.wallpapers" "/new/path"
push_json_array() {
    local key="$1"
    local value="$2"

    if [[ -z "$key" || -z "$value" ]]; then
        $print_debug "Error: Both key and value are required" -t "error"
        return 1
    fi

    init_metadata_json || return 1
    _acquire_metadata_lock || $print_debug "Warning: could not acquire lock, proceeding without it" -t "debug" --redirect-to-stderr

    local temp_file
    temp_file=$(_mktemp_metadata) || {
        _release_metadata_lock
        $print_debug "Failed to create temporary file" -t "error"
        return 1
    }

    if jq --arg key "$key" --arg val "$value" '
        ($key|split(".")) as $p
        | setpath($p; ((getpath($p) // []) + [$val]))
    ' "$METADATA_JSON" > "$temp_file" && mv "$temp_file" "$METADATA_JSON"; then
        $print_debug "Pushed to array $key: $value" -t "debug" --redirect-to-stderr
        _release_metadata_lock
        return 0
    else
        rm -f "$temp_file"
        _release_metadata_lock
        $print_debug "Failed to push to array: $key" -t "error"
        return 1
    fi
}

# Pop element from end of array (returns the popped element) at nested path
# Usage: popped_value=$(pop_json_array "cache.wallpapers")
pop_json_array() {
    local key="$1"

    if [[ -z "$key" ]]; then
        $print_debug "Error: Variable key is required" -t "error"
        return 1
    fi

    if [[ ! -f "$METADATA_JSON" ]]; then
        echo ""
        return 0
    fi

    local last_element
    last_element=$(jq -r --arg key "$key" '
        (getpath(($key|split("."))) // [])[-1] // empty
    ' "$METADATA_JSON" 2>/dev/null)

    if [[ -n "$last_element" ]]; then
        _acquire_metadata_lock || $print_debug "Warning: could not acquire lock, proceeding without it" -t "debug" --redirect-to-stderr
        local temp_file
        temp_file=$(_mktemp_metadata) || {
            _release_metadata_lock
            $print_debug "Failed to create temporary file" -t "error"
            return 1
        }
        if jq --arg key "$key" '
            ($key|split(".")) as $p
            | setpath($p; ((getpath($p) // [])[:-1]))
        ' "$METADATA_JSON" > "$temp_file" && mv "$temp_file" "$METADATA_JSON"; then
            echo "$last_element"
            _release_metadata_lock
            $print_debug "Popped from array $key: $last_element" -t "debug" --redirect-to-stderr
            return 0
        else
            rm -f "$temp_file"
            _release_metadata_lock
            $print_debug "Failed to pop from array: $key" -t "error"
            return 1
        fi
    else
        echo ""
        return 0
    fi
}

# Unshift element to beginning of array (nested path)
# Usage: unshift_json_array "cache.wallpapers" "/new/path"
unshift_json_array() {
    local key="$1"
    local value="$2"

    if [[ -z "$key" || -z "$value" ]]; then
        $print_debug "Error: Both key and value are required" -t "error"
        return 1
    fi

    init_metadata_json || return 1
    _acquire_metadata_lock || $print_debug "Warning: could not acquire lock, proceeding without it" -t "debug" --redirect-to-stderr

    local temp_file
    temp_file=$(_mktemp_metadata) || {
        _release_metadata_lock
        $print_debug "Failed to create temporary file" -t "error"
        return 1
    }

    if jq --arg key "$key" --arg val "$value" '
        ($key|split(".")) as $p
        | setpath($p; ([$val] + (getpath($p) // [])))
    ' "$METADATA_JSON" > "$temp_file" && mv "$temp_file" "$METADATA_JSON"; then
        $print_debug "Unshifted to array $key: $value" -t "debug" --redirect-to-stderr
        _release_metadata_lock
        return 0
    else
        rm -f "$temp_file"
        _release_metadata_lock
        $print_debug "Failed to unshift to array: $key" -t "error"
        return 1
    fi
}

# Shift element from beginning of array (returns the shifted element) at nested path
# Usage: shifted_value=$(shift_json_array "cache.wallpapers")
shift_json_array() {
    local key="$1"

    if [[ -z "$key" ]]; then
        $print_debug "Error: Variable key is required" -t "error"
        return 1
    fi

    if [[ ! -f "$METADATA_JSON" ]]; then
        echo ""
        return 0
    fi

    local first_element
    first_element=$(jq -r --arg key "$key" '
        (getpath(($key|split("."))) // [])[0] // empty
    ' "$METADATA_JSON" 2>/dev/null)

    if [[ -n "$first_element" ]]; then
        _acquire_metadata_lock || $print_debug "Warning: could not acquire lock, proceeding without it" -t "debug" --redirect-to-stderr
        local temp_file
        temp_file=$(_mktemp_metadata) || {
            _release_metadata_lock
            $print_debug "Failed to create temporary file" -t "error"
            return 1
        }
        if jq --arg key "$key" '
            ($key|split(".")) as $p
            | setpath($p; ((getpath($p) // [])[1:]))
        ' "$METADATA_JSON" > "$temp_file" && mv "$temp_file" "$METADATA_JSON"; then
            echo "$first_element"
            _release_metadata_lock
            $print_debug "Shifted from array $key: $first_element" -t "debug" --redirect-to-stderr
            return 0
        else
            rm -f "$temp_file"
            _release_metadata_lock
            $print_debug "Failed to shift from array: $key" -t "error"
            return 1
        fi
    else
        echo ""
        return 0
    fi
}

# Remove element from array by value (nested path)
# Usage: remove_json_array_element "cache.wallpapers" "/path/to/remove"
remove_json_array_element() {
    local key="$1"
    local value="$2"

    if [[ -z "$key" || -z "$value" ]]; then
        $print_debug "Error: Both key and value are required" -t "error"
        return 1
    fi

    if [[ ! -f "$METADATA_JSON" ]]; then
        return 0
    fi

    _acquire_metadata_lock || $print_debug "Warning: could not acquire lock, proceeding without it" -t "debug" --redirect-to-stderr

    local temp_file
    temp_file=$(_mktemp_metadata) || {
        _release_metadata_lock
        $print_debug "Failed to create temporary file" -t "error"
        return 1
    }

    if jq --arg key "$key" --arg val "$value" '
        ($key|split(".")) as $p
        | setpath($p; ((getpath($p) // []) | map(select(. != $val))))
    ' "$METADATA_JSON" > "$temp_file" && mv "$temp_file" "$METADATA_JSON"; then
        $print_debug "Removed from array $key: $value" -t "debug" --redirect-to-stderr
        _release_metadata_lock
        return 0
    else
        rm -f "$temp_file"
        _release_metadata_lock
        $print_debug "Failed to remove from array: $key" -t "error"
        return 1
    fi
}

# Check if array contains element (nested with flat-key fallback)
# Usage: if contains_json_array_element "cache.wallpapers" "/path"; then ...
contains_json_array_element() {
    local key="$1"
    local value="$2"

    if [[ -z "$key" || -z "$value" ]]; then
        return 1
    fi

    if [[ ! -f "$METADATA_JSON" ]]; then
        return 1
    fi

    local contains
    contains=$(jq --arg key "$key" --arg val "$value" '
        ((getpath(($key|split("."))) // .[$key]) // []) | any(. == $val)
    ' "$METADATA_JSON" 2>/dev/null)

    [[ "$contains" == "true" ]]
}

# ========= OBJECT OPERATIONS =========

# Set nested object (creates intermediate objects if needed) with nested path semantics
# Usage: set_json_object "wallpaper.current" '{"path": "/path", "name": "name", "effect": "effect"}'
set_json_object() {
    local key="$1"
    local object_json="$2"

    if [[ -z "$key" || -z "$object_json" ]]; then
        $print_debug "Error: Both key and object JSON are required" -t "error"
        return 1
    fi

    init_metadata_json || return 1
    _acquire_metadata_lock || $print_debug "Warning: could not acquire lock, proceeding without it" -t "debug" --redirect-to-stderr

    local temp_file
    temp_file=$(_mktemp_metadata) || {
        _release_metadata_lock
        $print_debug "Failed to create temporary file" -t "error"
        return 1
    }

    if jq --arg key "$key" --argjson obj "$object_json" '
        setpath(($key|split(".")); $obj)
        | (if ($key | contains(".")) then del(.[$key]) else . end)
    ' "$METADATA_JSON" > "$temp_file" && mv "$temp_file" "$METADATA_JSON"; then
        $print_debug "Set object $key" -t "debug" --redirect-to-stderr
        _release_metadata_lock
        return 0
    else
        rm -f "$temp_file"
        _release_metadata_lock
        $print_debug "Failed to set object: $key" -t "error"
        return 1
    fi
}

# Get object as JSON (nested with flat-key fallback)
# Usage: get_json_object "wallpaper.current"
get_json_object() {
    local key="$1"

    if [[ -z "$key" ]]; then
        $print_debug "Error: Variable key is required" -t "error"
        return 1
    fi

    if [[ ! -f "$METADATA_JSON" ]]; then
        echo "{}"
        return 0
    fi

    jq -c --arg key "$key" '
        ((getpath(($key|split("."))) // .[$key]) // {})
        | if type=="object" then . else {} end
    ' "$METADATA_JSON" 2>/dev/null
}

# Get object keys (nested with flat-key fallback)
# Usage: get_json_object_keys "wallpaper.current"
get_json_object_keys() {
    local key="$1"

    if [[ -z "$key" ]]; then
        $print_debug "Error: Variable key is required" -t "error"
        return 1
    fi

    if [[ ! -f "$METADATA_JSON" ]]; then
        return 0
    fi

    jq -r --arg key "$key" '
        ((getpath(($key|split("."))) // .[$key]) // {})
        | keys[]? // empty
    ' "$METADATA_JSON" 2>/dev/null
}

# Merge object (deep merge) at nested path; remove legacy flat key
# Usage: merge_json_object "wallpaper.current" '{"effect": "new_effect", "extra": "value"}'
merge_json_object() {
    local key="$1"
    local merge_json="$2"

    if [[ -z "$key" || -z "$merge_json" ]]; then
        $print_debug "Error: Both key and merge JSON are required" -t "error"
        return 1
    fi

    init_metadata_json || return 1
    _acquire_metadata_lock || $print_debug "Warning: could not acquire lock, proceeding without it" -t "debug" --redirect-to-stderr

    local temp_file
    temp_file=$(_mktemp_metadata) || {
        _release_metadata_lock
        $print_debug "Failed to create temporary file" -t "error"
        return 1
    }

    if jq --arg key "$key" --argjson merge "$merge_json" '
        . as $root
        | ($key|split(".")) as $p
        | setpath($p; ((getpath($p) // {}) * $merge))
        | (if ($key | contains(".")) then del(.[$key]) else . end)
    ' "$METADATA_JSON" > "$temp_file" && mv "$temp_file" "$METADATA_JSON"; then
        $print_debug "Merged object $key" -t "debug" --redirect-to-stderr
        _release_metadata_lock
        return 0
    else
        rm -f "$temp_file"
        _release_metadata_lock
        $print_debug "Failed to merge object: $key" -t "error"
        return 1
    fi
}

# Remove object key at nested path and also from legacy flat parent object if present
# Usage: remove_json_object_key "wallpaper.current" "effect"
remove_json_object_key() {
    local key="$1"
    local object_key="$2"

    if [[ -z "$key" || -z "$object_key" ]]; then
        $print_debug "Error: Both key and object key are required" -t "error"
        return 1
    fi

    if [[ ! -f "$METADATA_JSON" ]]; then
        return 0
    fi

    _acquire_metadata_lock || $print_debug "Warning: could not acquire lock, proceeding without it" -t "debug" --redirect-to-stderr

    local temp_file
    temp_file=$(_mktemp_metadata) || {
        _release_metadata_lock
        $print_debug "Failed to create temporary file" -t "error"
        return 1
    }

    if jq --arg key "$key" --arg obj_key "$object_key" '
        . as $root
        | ($key|split(".")) as $p
        | delpaths([$p + [$obj_key]])
        | (if (.[$key] | type=="object") then del(.[$key][$obj_key]) else . end)
    ' "$METADATA_JSON" > "$temp_file" && mv "$temp_file" "$METADATA_JSON"; then
        $print_debug "Removed object key $key.$object_key" -t "debug" --redirect-to-stderr
        _release_metadata_lock
        return 0
    else
        rm -f "$temp_file"
        _release_metadata_lock
        $print_debug "Failed to remove object key: $key.$object_key" -t "error"
        return 1
    fi
}

# Check if object has key (nested with flat-key fallback)
# Usage: if has_json_object_key "wallpaper.current" "effect"; then ...
has_json_object_key() {
    local key="$1"
    local object_key="$2"

    if [[ -z "$key" || -z "$object_key" ]]; then
        return 1
    fi

    if [[ ! -f "$METADATA_JSON" ]]; then
        return 1
    fi

    local has_key
    has_key=$(jq -r --arg key "$key" --arg k "$object_key" '
        ((getpath(($key|split("."))) // .[$key]) // {}) | has($k)
    ' "$METADATA_JSON" 2>/dev/null)

    [[ "$has_key" == "true" ]]
}

# ========= UTILITY OPERATIONS =========

# Pretty print JSON (for debugging)
# Usage: pretty_print_json_metadata
pretty_print_json_metadata() {
    if [[ -f "$METADATA_JSON" ]]; then
        jq '.' "$METADATA_JSON"
    else
        echo "{}"
    fi
}

# Backup metadata
# Usage: backup_json_metadata "/path/to/backup.json"
backup_json_metadata() {
    local backup_path="$1"

    if [[ -z "$backup_path" ]]; then
        $print_debug "Error: Backup path is required" -t "error"
        return 1
    fi

    if [[ -f "$METADATA_JSON" ]]; then
        cp "$METADATA_JSON" "$backup_path" || {
            $print_debug "Failed to backup metadata to: $backup_path" -t "error"
            return 1
        }
        $print_debug "Backed up metadata to: $backup_path" -t "debug" --redirect-to-stderr
    else
        echo '{}' > "$backup_path"
        $print_debug "Created empty backup at: $backup_path" -t "debug" --redirect-to-stderr
    fi

    return 0
}

# Restore metadata from backup
# Usage: restore_json_metadata "/path/to/backup.json"
restore_json_metadata() {
    local backup_path="$1"

    if [[ -z "$backup_path" ]]; then
        $print_debug "Error: Backup path is required" -t "error"
        return 1
    fi

    if [[ ! -f "$backup_path" ]]; then
        $print_debug "Error: Backup file not found: $backup_path" -t "error"
        return 1
    fi

    init_metadata_json || return 1

    cp "$backup_path" "$METADATA_JSON" || {
        $print_debug "Failed to restore metadata from: $backup_path" -t "error"
        return 1
    }

    $print_debug "Restored metadata from: $backup_path" -t "debug" --redirect-to-stderr
    return 0
}

# Export functions for use in other scripts (with error handling for compatibility)
{
    export -f set_json_var set_json_var_json get_json_var has_json_var unset_json_var list_json_vars set_json_vars dump_json_vars
    export -f set_json_array get_json_array get_json_array_length get_json_array_element set_json_array_element
    export -f push_json_array pop_json_array unshift_json_array shift_json_array
    export -f remove_json_array_element contains_json_array_element
    export -f set_json_object get_json_object get_json_object_keys merge_json_object
    export -f remove_json_object_key has_json_object_key
    export -f pretty_print_json_metadata backup_json_metadata restore_json_metadata
} 2>/dev/null || {
    # Functions are still available in current shell, just not exported to subshells
    # This handles environments where export -f may not be supported
    true
}
